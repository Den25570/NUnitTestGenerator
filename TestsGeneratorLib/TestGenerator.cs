using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using System.Reflection;
using Microsoft.CSharp;
using System.CodeDom;

namespace TestsGeneratorLib
{
    public static class TestGenerator
    {
        private static SyntaxList<UsingDirectiveSyntax> getTemplateUsing(string namespaceName)
        {
            List<UsingDirectiveSyntax> template = new List<UsingDirectiveSyntax>
            {
                UsingDirective(IdentifierName("System")),
                UsingDirective(QualifiedName(
                    IdentifierName("System"),
                    IdentifierName("Linq"))),
                UsingDirective(QualifiedName(
                    QualifiedName(
                        IdentifierName("System"), IdentifierName("Collections")),
                        IdentifierName("Generic"))),
                UsingDirective(
                    QualifiedName(
                        QualifiedName(
                            QualifiedName(
                                IdentifierName("Microsoft"),
                                IdentifierName("VisualStudio")),
                            IdentifierName("TestTools")),
                    IdentifierName("UnitTesting"))),
                UsingDirective(IdentifierName(namespaceName))
            };

            return List(template);
        }

        private static string GetFullTypeName(string typeName)
        {
            var mscorlib = Assembly.GetAssembly(typeof(int));

            using (var provider = new CSharpCodeProvider())
            {
                foreach (var type in mscorlib.DefinedTypes)
                {
                    if (string.Equals(type.Namespace, "System"))
                    {
                        var typeRef = new CodeTypeReference(type);
                        var csTypeName = provider.GetTypeOutput(typeRef);
                        if (typeName == csTypeName)
                        {
                            return type.FullName;
                        }
                    }
                }
            }
            return null;
        }

        private static LiteralExpressionSyntax getTypeLiteral(string typeName)
        {
            object defalutValue;
            try
            {
                Type type = Type.GetType(typeName) ?? Type.GetType(GetFullTypeName(typeName));

                if (type.IsValueType && Nullable.GetUnderlyingType(type) == null)
                    defalutValue = Activator.CreateInstance(type);
                else
                    defalutValue = null;
            }
            catch
            {
                defalutValue = null;
            }

            if (defalutValue != null)
            {
                return 
                    LiteralExpression(
                        SyntaxKind.DefaultLiteralExpression,
                        ParseToken(defalutValue.ToString()));
            }
            else
            {
                return 
                    LiteralExpression(
                      SyntaxKind.NullLiteralExpression);
            }

        }

        private static SyntaxList<MemberDeclarationSyntax> getTemplateMethods(ClassDeclarationSyntax clsInfo, SemanticModel model)
        {
            List<MemberDeclarationSyntax> classMethods = new List<MemberDeclarationSyntax>();

            string templateBody = "Assert.Fail(\"autogenerated\");";
            string templateAttribute = "TestMethod";

            //add setUp
            var constructor = (ConstructorDeclarationSyntax)clsInfo.ChildNodes().FirstOrDefault(n => n.Kind() == SyntaxKind.ConstructorDeclaration);
            if (constructor != null)
            {
                List<StatementSyntax> statements = new List<StatementSyntax>();
                List<ArgumentSyntax> constructorParams = new List<ArgumentSyntax>();

                foreach (ParameterSyntax parameter in constructor.ParameterList.ChildNodes().Cast<ParameterSyntax>())
                {
                    var typeSymbol = model.GetSymbolInfo(parameter.Type).Symbol as INamedTypeSymbol;
                    var typeName = typeSymbol.ToString().Substring(typeSymbol.ToString().LastIndexOf(".") + 1);
                    if (typeName.First() == 'I')
                    {
                        var variable = ExpressionStatement(
                            AssignmentExpression(
                                SyntaxKind.SimpleAssignmentExpression,
                                IdentifierName(char.ToLower(typeName[1]) + typeName.Substring(2)),
                                ObjectCreationExpression(
                                    GenericName(
                                        Identifier("Mock"))
                                    .WithTypeArgumentList(
                                        TypeArgumentList(
                                            SingletonSeparatedList<TypeSyntax>(
                                                IdentifierName(typeName)))))
                                .WithArgumentList(
                                    ArgumentList())));
                        constructorParams.Add(Argument(IdentifierName(char.ToLower(typeName[1]) + typeName.Substring(2) + ".Object")));
                        statements.Add(variable);                       
                    }
                    else
                    {
                        constructorParams.Add(Argument(getTypeLiteral(typeSymbol.ToString())));

                        /*var variable =
                            LocalDeclarationStatement(
                                VariableDeclaration(
                                    ParseTypeName(typeName),
                                    SeparatedList(new[] {
                                        VariableDeclarator(
                                            Identifier(char.ToLower(typeName[0]) + typeName.Substring(1)),
                                            null,
                                            getEqualsStatement(typeSymbol.ToString()))
                                    })
                            ));
                        statements.Add(variable);*/
                    }
                }
                var className = clsInfo.Identifier.ValueText;

                var classConstructorDeclaration = ExpressionStatement(
                    AssignmentExpression(
                          SyntaxKind.SimpleAssignmentExpression,
                          IdentifierName(char.ToLower(className[0]) + className.Substring(1)),
                          ObjectCreationExpression(
                              IdentifierName(className))
                              .WithArgumentList(
                                 ArgumentList(
                                    SeparatedList<ArgumentSyntax>(
                                      constructorParams)))));

                statements.Add(classConstructorDeclaration);

                //add setUp
                var declaration = MethodDeclaration(
                    PredefinedType(
                        Token(SyntaxKind.VoidKeyword)),
                    Identifier("SetUp"))
                    .WithAttributeLists(
                        SingletonList(
                            AttributeList(
                                SingletonSeparatedList(
                                    Attribute(
                                        IdentifierName("SetUp"))))))
                    .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                    .WithBody(Block(statements));

                classMethods.Add(declaration);
            }

            var publicMethods = clsInfo.DescendantNodes().OfType<MethodDeclarationSyntax>().Where(
                method => method.Modifiers.Any(modifier => modifier.ValueText == "public")).Select(obj => obj.Identifier.ValueText);
            foreach (var methodName in publicMethods)
            {
                //add testing methods
                var declaration = MethodDeclaration(
                    PredefinedType(
                        Token(SyntaxKind.VoidKeyword)),
                    Identifier(methodName + "Test"))
                    .WithAttributeLists(
                        SingletonList(
                            AttributeList(
                                SingletonSeparatedList(
                                    Attribute(
                                        IdentifierName(templateAttribute))))))
                    .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                    .WithBody(Block(ParseStatement(templateBody)));

                classMethods.Add(declaration);
            }

            return List(classMethods);
        }

        private static SyntaxList<MemberDeclarationSyntax> getTemplateFields(ClassDeclarationSyntax clsInfo, SemanticModel model)
        {           
            List<MemberDeclarationSyntax> classFields = new List<MemberDeclarationSyntax>();

            //add main object
            var className = clsInfo.Identifier.ValueText;
            FieldDeclarationSyntax field = FieldDeclaration(
                            VariableDeclaration(
                                ParseTypeName(className),
                                SeparatedList(new[] { VariableDeclarator(Identifier(char.ToLower(className[0]) + className.Substring(1))) })
                            ))
                            .AddModifiers(Token(SyntaxKind.PrivateKeyword));
            classFields.Add(field);

            //breakdown constructor / add mock objects
            var constructor = (ConstructorDeclarationSyntax)clsInfo.ChildNodes().FirstOrDefault(n => n.Kind() == SyntaxKind.ConstructorDeclaration);
            if (constructor != null)
            {
                foreach (ParameterSyntax parameter in constructor.ParameterList.ChildNodes().Cast<ParameterSyntax>())
                {
                    var typeSymbol = model.GetSymbolInfo(parameter.Type).Symbol as INamedTypeSymbol;
                    var typeName = typeSymbol.ToString().Substring(typeSymbol.ToString().LastIndexOf(".") + 1);
                    if (typeName.First() == 'I')
                    {
                        field = FieldDeclaration(
                            VariableDeclaration(
                                ParseTypeName($"Mock<{typeName}>"),
                                SeparatedList(new[] { VariableDeclarator(Identifier(char.ToLower(typeName[1]) + typeName.Substring(2))) })
                            ))
                            .AddModifiers(Token(SyntaxKind.PrivateKeyword));
                        classFields.Add(field);
                    }
                }
            }

            return List(classFields);
        }

        public static Task<List<GeneratedTestClass>> Generate(string code)
        {
            return Task.Run(() => {

                List<GeneratedTestClass> generatedClasses = new List<GeneratedTestClass>();

                var tree = CSharpSyntaxTree.ParseText(code);
                var syntaxRoot = tree.GetRoot();

                var mscorlib = MetadataReference.CreateFromFile(typeof(object).Assembly.Location);
                var compilation = CSharpCompilation.Create("MyCompilation",
                    syntaxTrees: new[] { tree }, references: new[] { mscorlib });
                var model = compilation.GetSemanticModel(tree);

                var classDeclarations = syntaxRoot.DescendantNodes().OfType<ClassDeclarationSyntax>();

                foreach (var clsInfo in classDeclarations)
                {
                    string className = clsInfo.Identifier.ValueText;
                    string clsNamespace = ((NamespaceDeclarationSyntax)clsInfo.Parent).Name.ToString();

                    NamespaceDeclarationSyntax template_namespace = NamespaceDeclaration(
                        QualifiedName(
                            IdentifierName(className), IdentifierName("Test")));

                    var template_usings = getTemplateUsing(clsNamespace);

                    var template_methods = getTemplateMethods(clsInfo, model);
                    var template_fields = getTemplateFields(clsInfo, model);
                    var template_members = List(template_fields.Concat(template_methods));

                    var template_classname = className + "Tests";                

                    //Class declaration
                    var classTemplate =
                      CompilationUnit()
                         .WithUsings(template_usings)
                         .WithMembers(SingletonList<MemberDeclarationSyntax>(template_namespace
                             .WithMembers(SingletonList<MemberDeclarationSyntax>(ClassDeclaration(template_classname)
                                 .WithAttributeLists(
                                     SingletonList(
                                         AttributeList(
                                             SingletonSeparatedList(
                                                 Attribute(
                                                     IdentifierName("TestClass"))))))
                                 .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                                 .WithMembers(template_members)))));

                    string generatedCode = classTemplate.NormalizeWhitespace().ToFullString();
                    string generatedName = template_classname + ".cs";

                    generatedClasses.Add(new GeneratedTestClass(generatedName, generatedCode));

                }

                return generatedClasses;

            });
        }
    }
}
